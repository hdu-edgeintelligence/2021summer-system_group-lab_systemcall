# 虚拟地址到物理地址转换
[toc]
# 多级页表寻址

- 内核在2.6.10 的基础上合入四级页表补丁
- 内核在 4.11-rc2 版本上合入五级页表，4.14最终融入
- linux目前支持5级页表寻址，但通常是4级寻址，可以通过cmdline控制内核使用4级还是5级页表

## 五级页表寻址机制参考图

![五级页表实现机制.jpg](%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20ccdb1ee6ad254609ba9f6fabf6b92707/%E4%BA%94%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.jpg)

## PGD

### pgd_offset()

```c
// include\linux\mm_types.h
struct mm_struct{
	...
	struct vm_area_struct *mmap; // vma链表
	pgd_t * pgd;                 // typedef struct { pgdval_t pgd; } pgd_t; typedef unsigned long	pgdval_t;
	...
};

// arch\x86\include\asm\pgtable.h
#define pgd_offset(mm, address) pgd_offset_pgd((mm)->pgd, (address))

#define pgd_offset_pgd(pgd, address) (pgd + pgd_index((address)))

/* 
	PTRS_PER_PGD; // pgd 中可包含的指针数
	PGDIR_SHIFT; // pud pmd pte offset加起来的地址位数
*/
#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
```

## P4D

### p4d_t

```c
// arch\x86\include\asm\pgtable_types.h
typedef struct { p4dval_t p4d; } p4d_t;

// arch\x86\include\asm\pgtable-3level_types.h
typedef u64	p4dval_t;
```

### p4d_offset()

```c

/* 对于p4d_offset中为什么if判断pgtable_l5_enabled
// arch\x86\Kconfig
config PGTABLE_LEVELS
	int
	default 5 if X86_5LEVEL
	default 4 if X86_64
	default 3 if X86_PAE
	default 2

// arch\x86\include\asm\pgtable_64_types.h
#ifdef CONFIG_X86_5LEVEL
	extern unsigned int __pgtable_l5_enabled;
	#ifndef pgtable_l5_enabled
		#define pgtable_l5_enabled cpu_feature_enabled(X86_FEATURE_LA57)
	#endif
#else
	#define pgtable_l5_enabled 0
#endif

// 上面两段定义可见如果定义了CONFIG_X86_5LEVEL,则CONFIG_PGTABLE_LEVELS = 5
// 所以p4d_offset()中对于pgtable_l5_enabled的if判断是？
// 是因为会在某些地方会改变该值，而不改变内核配置选项？
// 是在什么地方改变的呢？cmdline?
*/

// arch\x86\include\asm\pgtable.h
#if CONFIG_PGTABLE_LEVELS > 4
static inline p4d_t *p4d_offset(pgd_t *pgd, unsigned long address)
{
	if (!pgtable_l5_enabled)
		return (p4d_t *)pgd;
	return (p4d_t *)pgd_page_vaddr(*pgd) + p4d_index(address);
}

// pgd_val获取pgd指向的页全局目录项，它和PTE_PFN_MASK相与获得该项对应的物理页框号
// 再使用__val()将获得的物理页框号转换位虚拟地址
// 这里使用_val()可以理解为：我们操作的pgd_t变量是虚拟地址空间的，但里面存储的值是物理地址，
// 即页表在物理内存中实际存储位置，同理，p4d_t、pud_t、pmd_t也是如此
static inline unsigned long pgd_page_vaddr(pgd_t pgd)
{
	return (unsigned long)__va((unsigned long)pgd_val(pgd) & PTE_PFN_MASK);
}

```

### p4d_index()

```c
// PTRS_PER_P4D：pgd 中可包含的指针数
// P4D_SHIFT：其他下级页表和offset加起来的位数
static inline unsigned long p4d_index(unsigned long address)
{
	return (address >> P4D_SHIFT) & (PTRS_PER_P4D - 1);
}
```

### pgd_bad 和pgd_none

```c
// 似乎不用管，先跳过，解释可以看参考文章
static inline int pgd_bad(pgd_t pgd)
{
	unsigned long ignore_flags = _PAGE_USER;

	if (!pgtable_l5_enabled)
		return 0;

	if (IS_ENABLED(CONFIG_PAGE_TABLE_ISOLATION))
		ignore_flags |= _PAGE_NX;

	return (pgd_flags(pgd) & ~ignore_flags) != _KERNPG_TABLE;
}

/* 判断页表项是否为空 */
static inline int pgd_none(pgd_t pgd)
{
	if (!pgtable_l5_enabled)
		return 0;
	/*
	 * There is no need to do a workaround for the KNL stray
	 * A/D bit erratum here.  PGDs only point to page tables
	 * except on 32-bit non-PAE which is not supported on
	 * KNL.
	 */
	return !native_pgd_val(pgd);
}
```

### __va()

```c
// arch\x86\include\asm\page.h
// PAGE_OFFSET是内核空间和用户空间对虚拟地址空间的划分,32位系统中PAGE_OFFSET=0xC0000000
// __va(x) 用于将物理地址转化位虚拟地址
#ifndef __va
#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
#endif
```

## PUD

### pud_offset()

```c
#if CONFIG_PGTABLE_LEVELS > 3
// 返回1, 则表项为空
static inline int p4d_none(p4d_t p4d)
{
	return (native_p4d_val(p4d) & ~(_PAGE_KNL_ERRATUM_MASK)) == 0;
}

static inline int p4d_present(p4d_t p4d)
{
	return p4d_flags(p4d) & _PAGE_PRESENT;
}

static inline unsigned long p4d_page_vaddr(p4d_t p4d)
{
	return (unsigned long)__va(p4d_val(p4d) & p4d_pfn_mask(p4d));
}

/* Find an entry in the third-level page table.. */
static inline pud_t *pud_offset(p4d_t *p4d, unsigned long address)
{
	return (pud_t *)p4d_page_vaddr(*p4d) + pud_index(address);
}
```

### pud_index()

```c
static inline unsigned long pud_index(unsigned long address)
{
	return (address >> PUD_SHIFT) & (PTRS_PER_PUD - 1);
}
```

## PMD

### pmd_offset()

```c
#if CONFIG_PGTABLE_LEVELS > 2
static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
{
	return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
}

static inline unsigned long pud_page_vaddr(pud_t pud)
{
	return (unsigned long)__va(pud_val(pud) & pud_pfn_mask(pud));
}

```

### pmd_index()

```c

static inline unsigned long pmd_index(unsigned long address)
{
	return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
}
```

### pud_none()和pud_bad()

```c
static inline int pud_none(pud_t pud)
{
	return (native_pud_val(pud) & ~(_PAGE_KNL_ERRATUM_MASK)) == 0;
}

// 查看页表项P标志位查看对应下级页表是否在内存
static inline int pud_present(pud_t pud)
{
	return pud_flags(pud) & _PAGE_PRESENT;
}

static inline int pmd_bad(pmd_t pmd)
{
	return (pmd_flags(pmd) & ~_PAGE_USER) != _KERNPG_TABLE;
}
```

## PTE

### pte_offset_kernel()

```c
static inline pte_t *pte_offset_kernel(pmd_t *pmd, unsigned long address)
{
	return (pte_t *)pmd_page_vaddr(*pmd) + pte_index(address);
}

static inline unsigned long pmd_page_vaddr(pmd_t pmd)
{
	return (unsigned long)__va(pmd_val(pmd) & pmd_pfn_mask(pmd));
}

static inline unsigned long pte_index(unsigned long address)
{
	return (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);
}
```

### pmd_none()和pmd_bad()

```c
// arch\x86\include\asm\pgtable.h
static inline int pmd_none(pmd_t pmd)
{
	/* Only check low word on 32-bit platforms, since it might be
	   out of sync with upper half. */
	unsigned long val = native_pmd_val(pmd);
	return (val & ~_PAGE_KNL_ERRATUM_MASK) == 0;
}

static inline int pmd_bad(pmd_t pmd)
{
	return (pmd_flags(pmd) & ~_PAGE_USER) != _KERNPG_TABLE;
}
```

### pte_pfn()

```c
// arch\x86\include\asm\page_types.h
// _AC(1,UL)这里似乎是控制页面的大小？是否是huge page？关于UL没看懂定义
#define PAGE_SHIFT		12
#define PAGE_SIZE		(_AC(1,UL) << PAGE_SHIFT)
#define PAGE_MASK		(~(PAGE_SIZE-1))

// arch\x86\include\asm\pgtable_types.h
/* Extracts the PFN from a (pte|pmd|pud|pgd)val_t of a 4KB page */
#define PTE_PFN_MASK		((pteval_t)PHYSICAL_PAGE_MASK)

// arch\x86\include\asm\page_types.h
#define PHYSICAL_PAGE_MASK	(((signed long)PAGE_MASK) & __PHYSICAL_MASK)

// arch\x86\include\asm\pgtable.h
/* 
pte表项内容为 PPN(physical page number) + flags(页表项低12位为标志位)
通过与PTE_PFN_MASK相与获得物理页面基址,右移 PAGE_SHIFT位之后得到物理页框号PFN(pysical frame number)
*/
static inline unsigned long pte_pfn(pte_t pte)
{
	return (pte_val(pte) & PTE_PFN_MASK) >> PAGE_SHIFT;
}
```

# Linux页表寻址实现

```c
// mm\memory.c
// 先不管
static int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,
			    unsigned long *start, unsigned long *end,
			    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;

	p4d = p4d_offset(pgd, address);
	if (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))
		goto out;

	pud = pud_offset(p4d, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));

	if (pmd_huge(*pmd)) {
		if (!pmdpp)
			goto out;

		if (start && end) {
			*start = address & PMD_MASK;
			*end = *start + PMD_SIZE;
			mmu_notifier_invalidate_range_start(mm, *start, *end);
		}
		*ptlp = pmd_lock(mm, pmd);
		if (pmd_huge(*pmd)) {
			*pmdpp = pmd;
			return 0;
		}
		spin_unlock(*ptlp);
		if (start && end)
			mmu_notifier_invalidate_range_end(mm, *start, *end);
	}

	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;

	if (start && end) {
		*start = address & PAGE_MASK;
		*end = *start + PAGE_SIZE;
		mmu_notifier_invalidate_range_start(mm, *start, *end);
	}
	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
	if (start && end)
		mmu_notifier_invalidate_range_end(mm, *start, *end);
out:
	return -EINVAL;
}
```

# 参考

- [blog《浅谈五级页表》Leon_Geo](https://www.jianshu.com/p/bb5f2124be17)
- [blog《Linux内核追踪[4.14] X86的5级页表管理》qixuan.wu](https://blog.csdn.net/lovelycheng/article/details/78545502)
- [stackoverflow 《what is meaning of pgd_bad, pmd_bad, pud_bad, while converting kernel addressess?》](https://stackoverflow.com/questions/36887092/what-is-meaning-of-pgd-bad-pmd-bad-pud-bad-while-converting-kernel-addressess)
- [csdn《Linux内存管理 - PAGE_OFFSET理解》vonzhou](https://blog.csdn.net/vonzhoufz/article/details/42584053)
- c[sdn 《linux 内核页表替换》 inquisiter](https://blog.csdn.net/bme314/article/details/103601379)
- [blog 《Linux 内核源码分析-内存分页机制》 Leviathan](https://www.leviathan.vip/2019/02/16/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/)
- [知乎《虚拟地址转换[二] - 具体实现》兰新宇](https://zhuanlan.zhihu.com/p/65348145)