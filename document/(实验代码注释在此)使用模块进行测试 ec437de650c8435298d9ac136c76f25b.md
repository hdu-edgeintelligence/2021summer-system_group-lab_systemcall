# (实验代码注释在此)使用模块进行测试
[toc]
# 为什么要使用模块

- 因为我们添加的是系统调用，编译内核太麻烦了，所以先用模块来试试水。
- 另外，不想在系统调用相关文件中留下注释，所以把注释留在这里。

# 模块编写

## sclab.c

```c
#include <linux/module.h>     // 模块的结构定义和版本控制
#include <linux/kernel.h>     // 常用内核函数
#include <linux/init.h>       // 宏 __init和__exit
#include <linux/sched.h>      // 进程描述符定义
#include <linux/pid.h>        // pid相关操作函数
#include <asm/pgtable.h>	  // 页表结构定义

MODULE_LICENSE("GPL");                                 // 模块许可证，这里设为GNU公共许可证
MODULE_AUTHOR("huomax");                               // 模块作者
MODULE_DESCRIPTION("Input PFN of appoint pid !");  // 模块简单描述
MODULE_VERSION("0.01");                                // 模块版本

static int pid = 0;
module_param(pid,int,S_IRUGO);                         // 模块传参，指定进程进程号

static unsigned long vp_to_pp(unsigned long address,struct mm_struct *mm)                          // 通过虚拟地址查询对应物理页框号                        
{
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	unsigned long PFN = 0x0;																	// physical frame number

	/* 获取进程在 PGD Table Directory 中的入口 */
	pgd = pgd_offset(mm,address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd))){
		// printk(KERN_ALTER"PGD Table Directory entry is empty!");
		return 0;
	}

	/* 获取进程在 P4d Table Directory 中的入口 */
	p4d = p4d_offset(pgd,address);														// 在4级页面机制中，不做任何操作，直接返回pgd
	if (p4d_none(*p4d) || unlikely(p4d_bad(*p4d))){
		// printk(KERN_ALTER"P4d Table Directory entry is empty!");
		return 0;
	}

	/* 获取进程在 PUD Table Directory 中的入口 */
	pud = pud_offset(p4d,address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud))){
		// printk(KERN_ALTER"PUD Table Directory entry is empty!");
		return 0;
	}

	/* 获取进程在 PMD Table Directory 中的入口 */
	pmd = pmd_offset(pud,address);
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd))){
		// printk(KERN_ALTER"PMD Table Directory entry is empty!");
		return 0;
	}

	/* 获取进程在 PTE Table Directory 中的入口 */
	pte = pte_offset_kernel(pmd,address);
	if (pte_none(*pte)){
		// printk(KERN_ALTER"PTE Table Directory entry is empty!");
		return 0;
	}

	/* 获取虚拟地址 address 对应的 物理页框号 pfn*/
	PFN = pte_pfn(*pte);
	// printk("Successful address switch !");
	return PFN;

}
static int __init sclab_init(void){

	struct task_struct *sctask;
	struct mm_struct *scmm;
	struct vm_area_struct *scmmap;

	unsigned long tra_vpaddr;                                                             // 遍历VMA地址范围内每一个虚拟页面首地址
	unsigned long PFN;														              // 保存当前已分配物理页框号

	// unsigned long pgsize = 0x1000;                                                        // 页面大小为4KB

	unsigned int statistic_vp = 0x0;															// 统计虚拟内存页面数量
	unsigned int statistic_pfn = 0x0; 															// 统计分配给进程的物理页框数量

	/* 获取当前操作系统页表机制级数 */
	printk("CONFIG_PGTABLE_LEVELS: %d ",CONFIG_PGTABLE_LEVELS);

	/* 获取指定进程号PID的任务描述符 */
	sctask = pid_task(find_get_pid(pid),PIDTYPE_PID);

	/* 通过进程描述符的 struct mm_struct 结构获取进程的虚拟地址*/
	scmm = sctask->mm;
	scmmap = scmm->mmap;

	/* 输出进程基本信息 */
	printk("task->pid:%d",sctask->pid);
	printk("task->comm:%s",sctask->comm);

	/* 查询指定进程已分配的虚拟内存页面对应的物理页面 */
	while(scmmap != NULL){
		// printk("VMA_start:%lx	VMA_end:%lx",scmmap->vm_start,scmmap->vm_end);						// 输出VMA地址范围
		for(tra_vpaddr = scmmap->vm_start; tra_vpaddr < scmmap->vm_end; tra_vpaddr += PAGE_SIZE)  	// 在VMA地址范围内遍历每一个虚拟页面首地址
		{
			statistic_vp++;
			PFN = vp_to_pp(tra_vpaddr,scmm);                                        				// 调用vp_to_pp()查询虚拟页面对应物理页框号
			if(!PFN){																				// 某一级页表项为空
				continue;
			}
			statistic_pfn++;
			printk("VP:%lx  PFN:%lx\n",tra_vpaddr,PFN);
		}
		scmmap = scmmap->vm_next;
	}

	printk("statistic_vp_number:%d statistic_pfn_number:%d",statistic_vp,statistic_pfn);

	/* 输出内核栈地址 */
	printk("TASK_STACK:%lx\n",*(unsigned long *)(sctask->stack));

	printk("end input !\n");
	return 0;
}

static void __exit sclab_exit(void){
	printk("sclab mod uninstall!\n");
}

module_init(sclab_init);   // 注册模块初始化函数
module_exit(sclab_exit);   // 注册模块注销函数
```

## Makefile

```c
obj-m :=sclab.o # 使用目标文件sclab.o建立一个模块，模块名为sclab.ko
all:
        make -C /lib/modules/$(shell uname -r)/build SUBDIRS=$(PWD) modules    # 编译模块
clean: 
        make -C /lib/modules/$(shell uname -r)/build SUBDIRS=$(PWD) clean      # 清理模块
```

## 模块安装

```c
$ make 2>error.log
$ insmod sclab.ko pid=pid // 这里第二个pid是你指定的进程号.可以在另一个窗口使用top命令，输入top进程的pid
```

## 模块输出

```c
$ dmesg
[  114.421313] sclab: module verification failed: signature and/or required key missing - tainting kernel
[  114.422792] CONFIG_PGTABLE_LEVELS: 4 
[  114.422793] task->pid:2260
[  114.422794] task->comm:top
[  114.422795] VP:557dcaabf000  PFN:141443
[  114.422795] VP:557dcaac0000  PFN:141445
[  114.422795] VP:557dcaac1000  PFN:141446
[  114.422796] VP:557dcaac2000  PFN:141a93
[  114.422796] VP:557dcaac3000  PFN:14149d
[  114.422796] VP:557dcaac4000  PFN:1414bf
[  114.422796] VP:557dcaac5000  PFN:1414c0
[  114.422796] VP:557dcaac6000  PFN:1414d1
.....................
.....................
.....................
[  114.423076] VP:7ffd9f7c0000  PFN:14438c
[  114.423077] VP:7ffd9f7c1000  PFN:1414e1
[  114.423077] VP:7ffd9f7c2000  PFN:121119
[  114.423077] VP:7ffd9f7c3000  PFN:141a95
[  114.423077] VP:7ffd9f7cd000  PFN:15108a
[  114.423078] VP:7ffd9f7d0000  PFN:150b98
[  114.423078] statistic_vp_number:11534 statistic_pfn_number:1081
[  114.423079] TASK_STACK:57ac6e9d
[  114.423079] end input !
```

## 测试输出是否正确

- 目前没找办法