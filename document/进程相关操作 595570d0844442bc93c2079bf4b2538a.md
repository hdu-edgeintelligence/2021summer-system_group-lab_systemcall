# 进程相关操作
[toc]
# PID

## 通过 pid 获取任务描述符task_struct

```c
struct task_struct *task;
task = pid_task(find_get_pid(pid),PIDTYPE_PID);
```

## pid_task()

```c

// include\linux\pid.h
struct pid
{
	atomic_t count;
	unsigned int level;
	/* lists of tasks that use this pid */
	struct hlist_head tasks[PIDTYPE_MAX];
	struct rcu_head rcu;
	struct upid numbers[1];
};

enum pid_type
{
	PIDTYPE_PID,   //进程的进程号
	PIDTYPE_PGID,  //进程组领头进程的进程号
	PIDTYPE_SID,   //会话领头进程的进程号
	PIDTYPE_MAX,   
	/* only valid to __task_pid_nr_ns() */
	__PIDTYPE_TGID
};

// kernel\pid.c
// 通过 struct pid 获取进程号对应任务描述符 task_struct
struct task_struct *pid_task(struct pid *pid, enum pid_type type)
{
	struct task_struct *result = NULL;
	if (pid) {
		struct hlist_node *first;
		first = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),
					      lockdep_tasklist_lock_is_held());
		if (first)
			result = hlist_entry(first, struct task_struct, pids[(type)].node);
	}
	return result;
}
```

## find_get_pid()

```c
// 这里有几个概念
// 任务描述符 task_struct
// 进程描述符 struct pid
// 进程号 pid_t pid

// kernel\pid.c
// 根据进程号 pid_t pid 获取进程描述符,并将进程的PID应用加一
struct pid *find_get_pid(pid_t nr)
{
	struct pid *pid;

	rcu_read_lock();
	pid = get_pid(find_vpid(nr));
	rcu_read_unlock();

	return pid;
}

// 将进程的pid引用计数加一，这里是对原子操作的包装
static inline struct pid *get_pid(struct pid *pid)
{
	if (pid)
		atomic_inc(&pid->count);
	return pid;
}

// 根据进程号 int pid 获取进程描述符 struct pid
struct pid *find_vpid(int nr)
{
	return find_pid_ns(nr, task_active_pid_ns(current));
}

struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
	return idr_find(&ns->idr, nr);
}

```

![Untitled](%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%20595570d0844442bc93c2079bf4b2538a/Untitled.png)

# current

## current的简单使用

```c
// current 指向当前运行在CPU上的任务描述符 task_struct
current->pid
current->comm
....
```

## current宏的实现

- 太多了，不想写了，以后补

## 参考

- [blog《内核函数 获取进程描述符 struct pid》yldfree](https://blog.csdn.net/yldfree/article/details/80935253)
- [blog 《Linux进程管理内核API函数pid_task( )》cnbird2008](https://blog.csdn.net/cnbird2008/article/details/11560109)