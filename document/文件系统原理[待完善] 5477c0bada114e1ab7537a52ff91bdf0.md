# 文件系统原理[待完善]

# 实验思路

- 通过任务描述符task_struct获取files_struct
- 通过files_struct获取文件描述符表fdtable
- 通过文件描述符表获取文件描述符表指针
- 通过open_fds查找文件描述符位示图 bitmap，获取已经分配的文件描述符fd，继而通过fd[fd]获取进程与文件的会话file结构
- file→f_path.dentry→d_inode获取文件的inode
- 通过inode获取文件的address_space结构体，通过address_sapce的操作函数bmap()利用文件的逻辑块号查找文件数据的物理磁盘块号
- 备注：bmap()在ext4文件系统上被初始化为ext4_bmap()，还没看具体实现：
    - 原因1：这已经涉及到具体的文件系统实现了，我们接触的是VFS
    - 原因2：太麻烦了，没时间，看不下去
- 图 inode查找：

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled.png)

# 文件系统原理

## 文件系统的组成

### blocks

### inode

### bitmap

# VFS

## VFS是什么

VFS（virual file system）是虚拟文件系统，是一种建立在各种具体的文件系统之上的抽象层，用来屏蔽各种具体文件系统之间的差异，使操作系统能有一个统一的接口去操作文件

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled%201.png)

## VFS相关结构

## files_struct

这个结构体管理进程所打开的所有文件

```c
/*
 * include\linux\fdtable.h
 * #define NR_OPEN_DEFAULT BITS_PER_LONG 文件描述静态数组大小定义 64位系统为64
*/

struct files_struct {
  /*
   * read mostly part
   */
	atomic_t count;               // 引用计数
	bool resize_in_progress;     
	wait_queue_head_t resize_wait;

/*
 * 存放动态文件描述符
*/
	struct fdtable __rcu *fdt;                             // 文件打开表
	struct fdtable fdtab;

  /*
   * written part on a separate cache line in SMP
   */
	spinlock_t file_lock ____cacheline_aligned_in_smp;
	unsigned int next_fd;                                  // 用于查找下一个空闲的fd
	unsigned long close_on_exec_init[1];                   // 执行exec需要关闭的文件描述符的位图
	unsigned long open_fds_init[1];                        // 打开的文件描述符位图
	unsigned long full_fds_bits_init[1];                   // 文件描述符组位图，每一bit代表一组文件描述符是否空闲
	struct file __rcu * fd_array[NR_OPEN_DEFAULT];         // 文件描述符静态数组
};
```

## fdtable

这个结构体就是用来管理文件描述符fd的封装

```c
/*
 * include\linux\fdtable.h
*/
struct fdtable {
	unsigned int max_fds;         // fd数组边界，没扩充的话初始化为 NR_OPEN_DEFAULT 
	struct file __rcu **fd;       // 二级指针，指向存储fd的数组，数组元素是指针 struct file *
	unsigned long *close_on_exec; // 执行exec需要关闭的文件描述符的位图
	unsigned long *open_fds;      // bitmap 每一bit为0代表该文件描述符未被使用，为1则相反
	unsigned long *full_fds_bits; // bitmap组, 每一bit为0代表该组有可用的文件描述符，为1则相反
	struct rcu_head rcu;
};
```

## files_struct和fdtable

1. files_struct 和 fdtable之间的关系如图

![6.png](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/6.png)

1. 之所以会有这种复杂的嵌套结构，是因为linux综合考虑了资源问题，采用了动静态结合的方式存储文件描述符；fd_array[]存放静态文件描述符，其数组大小为操作系统位数；当进程打开的文件数量超过64个（假设这里是64位系统）之后，就会重新分配一个struct fdtable；分配并初始化新的struct fdtable变量后，原先指向fdtab的struct files_struct指针成员fdt，会调整为指向新分配的struct fdtable变量，即执行完上述的操作后，还要将旧的结构存储区的内容拷贝到新的存储区，这包括files_struct自身所包含的close_on_exec，open_fds，fd到新分配的close_on_exec，open_fds，fd的拷贝，如下图：

![7.png](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/7.png)

1. 扩充之后的fd数组大小为nr，并且将原有的file_array里面的内容也拷贝到新的fdtable指向的fd数组中；在完成上述拷贝之后，还要删除旧有的struct fdtable，但并不是现在删除，具体删除时刻见下面的代码：

### 扩充files_struct

进程能够打开的文件数量是有限制的，一般是NR_OPEN_DEFAULT个。而在fdtable中还表现为max_fds成员，是进程当前能够分配的文件描述符界限。当需要打开的文件数量超过max_fds之后，就需要对files_struct中存储struct file*指针数组进行扩充

```c
/*
 * fs\file.c
 * 扩充files_struct是通过expand_files()，expand_files()又调用了expand_fdtable()，expand_fdtable调用了copy_fdtable()实现新旧fdtable的拷贝
*/
static int expand_files(struct files_struct *files, unsigned int nr)
	__releases(files->file_lock)
	__acquires(files->file_lock)
{
	struct fdtable *fdt;
	int expanded = 0;

repeat:
	fdt = files_fdtable(files);    // files->fdt

/* 检查传入的参数，nr是要扩充的fd数组大小，如果小于旧有的fdtable中数组大小，则立刻返回 */
	if (nr < fdt->max_fds)         
		return expanded;

/* 检查要扩充的fd数组大小nr是否超过了系统规定的限制 */
	if (nr >= sysctl_nr_open)
		return -EMFILE;

/* 这里还没看，先跳过 */
	if (unlikely(files->resize_in_progress)) {
		spin_unlock(&files->file_lock);
		expanded = 1;
		wait_event(files->resize_wait, !files->resize_in_progress);
		spin_lock(&files->file_lock);
		goto repeat;
	}

/* All good, so we try */
	files->resize_in_progress = true;
	expanded = expand_fdtable(files, nr);
	files->resize_in_progress = false;

	wake_up_all(&files->resize_wait);
	return expanded;
}
```

```c
/*
 * 
*/
static int expand_fdtable(struct files_struct *files, unsigned int nr)
	__releases(files->file_lock)
	__acquires(files->file_lock)
{
	struct fdtable *new_fdt, *cur_fdt;

	spin_unlock(&files->file_lock);
	new_fdt = alloc_fdtable(nr);   // 分配一个fdtable，fdtable->fd指向nr*sizeof(struct file)大小的动态数组地址

	/* make sure all __fd_install() have seen resize_in_progress
	 * or have finished their rcu_read_lock_sched() section.
	 */
	if (atomic_read(&files->count) > 1)
		synchronize_sched();

	spin_lock(&files->file_lock);
	if (!new_fdt)
		return -ENOMEM;
	/*
	 * extremely unlikely race - sysctl_nr_open decreased between the check in
	 * caller and alloc_fdtable().  Cheaper to catch it here...
	 */
	if (unlikely(new_fdt->max_fds <= nr)) {
		__free_fdtable(new_fdt);
		return -EMFILE;
	}

	cur_fdt = files_fdtable(files);        // files->fdt
	BUG_ON(nr < cur_fdt->max_fds);
/*
 * 
*/
	copy_fdtable(new_fdt, cur_fdt);
	rcu_assign_pointer(files->fdt, new_fdt);
	if (cur_fdt != &files->fdtab)
		call_rcu(&cur_fdt->rcu, free_fdtable_rcu);
	/* coupled with smp_rmb() in __fd_install() */
	smp_wmb();
	return 1;
}
```

```c
/*
 * fdtable数据的拷贝是在这里实现的
*/
static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)
{
	unsigned int cpy, set;

	BUG_ON(nfdt->max_fds < ofdt->max_fds);

	cpy = ofdt->max_fds * sizeof(struct file *);
	set = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);

	memcpy(nfdt->fd, ofdt->fd, cpy);             // 拷贝原有fdtable的fd
	memset((char *)nfdt->fd + cpy, 0, set);      // 置位清零

	copy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);  // 拷贝原有fdtable的open_fds、close_on_exec
}
```

### 通过位图bitmap寻找有效fd

bitmap示意图(32位系统，BITS_PER_LONG被定义为32)

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled%202.png)

调用关系是：find_next_fd→find_next_zero_bit→_find_next_bit

```c
/*
 * fs\file.c 
 * start是位图偏移量，指定从位图中start开始的位置开始查找符合条件的bit位
*/
static unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)
{
	unsigned int maxfd = fdt->max_fds;                     // 获取当前最大的可用fd
	unsigned int maxbit = maxfd / BITS_PER_LONG;           // 查找最大可用fd所在bit组
	unsigned int bitbit = start / BITS_PER_LONG;           // 获取偏移量start所在bit组

/* 查找下一个可用bit组，结果乘以 BITS_PER_LONG则得到该可用bit组首个文件描述符 */
	bitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;     

/* 可用文件描述符起始值大于最大文件描述符，直接返回最大文件描述符，表示文件描述符需要扩展 */
	if (bitbit > maxfd)
		return maxfd;

/* 可用起始文件描述符大于参数传递的起始查找文件描述符，将开始查找的值从真正有效的值开始，避免做无效的查找 */
	if (bitbit > start)
		start = bitbit;

/* 从文件描述符表中查找可用的文件描述符 */
	return find_next_zero_bit(fdt->open_fds, maxfd, start);
}
```

```c
/*
 * lib\find_bit.c
*/
unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
				 unsigned long offset)
{
	return _find_next_bit(addr, NULL, size, offset, ~0UL);
}
```

```c
/*
 * lib\find_bit.c
 * nbit代表最大的bit数，start表示偏移量，从start开始搜索符合条件的bit位
 * bitmap 可以看为是一个二维数组，二维数组每一行表示一个向量
 */
static inline unsigned long _find_next_bit(const unsigned long *addr1,
		const unsigned long *addr2, unsigned long nbits,
		unsigned long start, unsigned long invert)
{
	unsigned long tmp;

/* 搜索偏移量大于位图最大允许bit数, 则返回bitmap最大允许bit数 */
	if (unlikely(start >= nbits))
		return nbits;

/* 获取偏移量start所在的bitmap中的位置向量（想象bitmap是一个二维数组，这里是判断start是在哪一个向量） */
	tmp = addr1[start / BITS_PER_LONG];
	if (addr2)
		tmp &= addr2[start / BITS_PER_LONG];

/* 对tmp取反, 对0的查找变为对1的查找，便于编码实现（bit组bitmap中bit=0代表有可用bit组，为1代表该bit组没有可用文件描述符） */
	tmp ^= invert;

/*
 * 获取位掩码，和tmp想与。表示将start之前的无效bit置零（是start所在的向量&&在start之前的bit置零）
 * #define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1))) 
*/
	tmp &= BITMAP_FIRST_WORD_MASK(start);

/* 将start低6位置零，start表示原start所在向量之前的向量的bit总数 */
	start = round_down(start, BITS_PER_LONG);

/* 循环体最后tmp ^= invert表示将tmp翻转 所以这里 */
	while (!tmp) {
		start += BITS_PER_LONG;
		if (start >= nbits)
			return nbits;

		tmp = addr1[start / BITS_PER_LONG];
		if (addr2)
			tmp &= addr2[start / BITS_PER_LONG];
		tmp ^= invert;
	}
/*
 * __ffs使用折半查找法查找传入参数的第一个为1的bit, 返回该bit位的索引
*/
	return min(start + __ffs(tmp), nbits);
}
```

## super_block

1. 每个super_block可以看成是一个已挂载的文件系统实例，它被每个底层文件系统(ext2,ext3,ext4,sysfs等)实现，用来存储描述特定文件系统的信息。
2. 每当一个文件系统被挂载时，它会调用alloc_super()方法，这个方法会去磁盘上读取superblock信息，然后用这些信息来初始化一个super_block对象

### struct super_block

```c
// include\linux\fs.h
struct super_block {
	struct list_head	s_list;	                   // linux所有super_block的链表
	dev_t			s_dev;		                         // 设备标识符
	unsigned char		s_blocksize_bits;            // 文件系统块大小(bit)
	unsigned long		s_blocksize;                 // 文件系统块大小
	loff_t			s_maxbytes;	                     // 最大文件大小
	struct file_system_type	*s_type;             // 文件系统类型，里面是对文件系统的细节描述
	const struct super_operations	*s_op;         // super_block操作函数集合
	const struct dquot_operations	*dq_op;        // 配额操作函数集合
	const struct quotactl_ops	*s_qcop;           // 配额控制操作函数集合
	const struct export_operations *s_export_op; // 网络文件系统的导出操作函数集合
	unsigned long		s_flags;
	unsigned long		s_iflags;	/* internal SB_I_* flags */
	unsigned long		s_magic;
	struct dentry		*s_root;                     // super_block指向根目录的dentry
	struct rw_semaphore	s_umount;                // 文件系统卸载时用到的读写信号量
	int			s_count;                             // 引用计数
	atomic_t		s_active;
#ifdef CONFIG_SECURITY
	void                    *s_security;
#endif
	const struct xattr_handler **s_xattr;

	const struct fscrypt_operations	*s_cop;

	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
	struct block_device	*s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info		*s_mtd;                  // 类内存设备信息
	struct hlist_node	s_instances;
	unsigned int		s_quota_types;	/* Bitmask of supported quota types */
	struct quota_info	s_dquot;	/* Diskquota specific options */

	struct sb_writers	s_writers;

	char			s_id[32];	                       // 文件系统名字
	uuid_t			s_uuid;		/* UUID */

	void 			*s_fs_info;	/* Filesystem private info */
	unsigned int		s_max_links;
	fmode_t			s_mode;

	/* Granularity of c/m/atime in ns.
	   Cannot be worse than a second */
	u32		   s_time_gran;

	/*
	 * The next field is for VFS *only*. No filesystems have any business
	 * even looking at it. You had been warned.
	 */
	struct mutex s_vfs_rename_mutex;	/* Kludge */

	/*
	 * Filesystem subtype.  If non-empty the filesystem type field
	 * in /proc/mounts will be "type.subtype"
	 */
	char *s_subtype;

	const struct dentry_operations *s_d_op; /* default d_op for dentries */

	/*
	 * Saved pool identifier for cleancache (-1 means none)
	 */
	int cleancache_poolid;

	struct shrinker s_shrink;	/* per-sb shrinker handle */

	/* Number of inodes with nlink == 0 but still referenced */
	atomic_long_t s_remove_count;

	/* Being remounted read-only */
	int s_readonly_remount;

	/* AIO completions deferred from interrupt context */
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;

	/*
	 * Owning user namespace and default context in which to
	 * interpret filesystem uids, gids, quotas, device nodes,
	 * xattrs and security labels.
	 */
	struct user_namespace *s_user_ns;

	/*
	 * Keep the lru lists last in the structure so they always sit on their
	 * own individual cachelines.
	 */
	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
	struct rcu_head		rcu;
	struct work_struct	destroy_work;

	struct mutex		s_sync_lock;	/* sync serialisation lock */

	/*
	 * Indicates how deep in a filesystem stack this SB is
	 */
	int s_stack_depth;

	/* s_inode_list_lock protects s_inodes */
	spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
	struct list_head	s_inodes;	/* all inodes */

	spinlock_t		s_inode_wblist_lock;
	struct list_head	s_inodes_wb;	/* writeback inodes */
} __randomize_layout;
```

### s_op

```c
// 内核对特定文件系统的调用
struct super_operations {
/* 在文件系统sb下，创建并初始化一个inode */
  struct inode *(*alloc_inode)(struct super_block *sb);

/* 释放inode */
	void (*destroy_inode)(struct inode *);

/* inode被修改之后调用 */
  void (*dirty_inode) (struct inode *, int flags);

/* 将inode写入磁盘 */
	int (*write_inode) (struct inode *, struct writeback_control *wbc);

/* 当inode 的引用计数为零时调用 */
	int (*drop_inode) (struct inode *);

/* 删除inode 由clear_inode和delete_inode合并*/
	void (*evict_inode) (struct inode *);

/* 卸载文件系统时由vfs调用，用来释放super_block */
	void (*put_super) (struct super_block *);

/* 使文件系统中的数据和磁盘上的数据同步 */
	int (*sync_fs)(struct super_block *sb, int wait);

	int (*freeze_super) (struct super_block *);
	int (*freeze_fs) (struct super_block *);
	int (*thaw_super) (struct super_block *);
	int (*unfreeze_fs) (struct super_block *);

/* 获取文件系统的状态 */
	int (*statfs) (struct dentry *, struct kstatfs *);

	int (*remount_fs) (struct super_block *, int *, char *);
	void (*umount_begin) (struct super_block *);

	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
#ifdef CONFIG_QUOTA
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot **(*get_dquots)(struct inode *);
#endif
	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
	long (*nr_cached_objects)(struct super_block *,
				  struct shrink_control *);
	long (*free_cached_objects)(struct super_block *,
				    struct shrink_control *);
};
```

## inode

- linux-4.17.12

```c
// include\linux\fs.h
/*
 * Keep mostly read-only and often accessed (especially for
 * the RCU path lookup and 'stat' data) fields at the beginning
 * of the 'struct inode'
 */
struct inode {
/* 文件的相关基本信息（权限、模式、uid、gid等） */
	umode_t			i_mode;              // 访问权限控制
	unsigned short		i_opflags;     // 记录inode节点操作标志位
	kuid_t			i_uid;               // 用户id
	kgid_t			i_gid;               // 用户组id
	unsigned int		i_flags;         // 文件系统标志

#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl; 
#endif

/* 回调函数 */
	const struct inode_operations	*i_op;  // vfs 文件操作函数
	struct super_block	*i_sb;            // inode相关的super_block
	struct address_space	*i_mapping;     // 相关的地址映射

#ifdef CONFIG_SECURITY
	void			*i_security;
#endif

	unsigned long		i_ino;                 // inode节点号

	union {
		const unsigned int i_nlink;          // inode节点硬链接数量
		unsigned int __i_nlink;
	};
	dev_t			i_rdev;                      // 主次设备号

/* 文件大小、文件访问时间、文件上次修改时间、文件属性上次修改时间 */
	loff_t			i_size;                    // 文件大小(字节)
	struct timespec		i_atime;             // 文件上次访问时间
	struct timespec		i_mtime;             // 文件上次修改时间
	struct timespec		i_ctime;             // 文件属性上次修改时间

/* i_blocks, i_bytes, maybe i_size */
	spinlock_t		i_lock;	                  // 自旋锁
	unsigned short          i_bytes;        // 使用的字节数
	unsigned int		i_blkbits;              // 块大小(bit)
	enum rw_hint		i_write_hint;           
	blkcnt_t		i_blocks;                   // 文件块数 unsigned long

#ifdef __NEED_I_SIZE_ORDERED
	seqcount_t		i_size_seqcount;
#endif

	/* Misc */
	unsigned long		i_state;                 // 状态标志
	struct rw_semaphore	i_rwsem;

	unsigned long		dirtied_when;	/* jiffies of first dirtying */
	unsigned long		dirtied_time_when;

	struct hlist_node	i_hash;                // 哈希表
	struct list_head	i_io_list;	/* backing dev IO list */
#ifdef CONFIG_CGROUP_WRITEBACK
	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */

	/* foreign inode detection, see wbc_detach_inode() */
	int			i_wb_frn_winner;
	u16			i_wb_frn_avg_time;
	u16			i_wb_frn_history;
#endif
	struct list_head	i_lru;		/* inode LRU list */
	struct list_head	i_sb_list;
	struct list_head	i_wb_list;	/* backing dev writeback list */
	union {
		struct hlist_head	i_dentry;
		struct rcu_head		i_rcu;
	};
	atomic64_t		i_version;             // 版本号
	atomic_t		i_count;                 // 引用计数
	atomic_t		i_dio_count;
	atomic_t		i_writecount;
#ifdef CONFIG_IMA
	atomic_t		i_readcount; /* struct files open RO */
#endif
	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
	struct file_lock_context	*i_flctx;
	struct address_space	i_data;         //设备地址映射
	struct list_head	i_devices;
	union {
		struct pipe_inode_info	*i_pipe;
		struct block_device	*i_bdev;
		struct cdev		*i_cdev;
		char			*i_link;
		unsigned		i_dir_seq;
	};

	__u32			i_generation;

#ifdef CONFIG_FSNOTIFY
	__u32			i_fsnotify_mask; /* all events this inode cares about */
	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
#endif

#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	struct fscrypt_info	*i_crypt_info;
#endif

/* 一个 vfs 和 后端具体文件系统的纽带, 用来传递一些具体文件系统使用的数据结构*/
	void			*i_private; /* fs or device private pointer */
} __randomize_layout;
```

### i_op

```c
// inode操作函数
struct inode_operations {
/* 
 * 在特定文件夹中寻找索引节点,该索引节点要对应于dentry中给出的文件名
 * 入参dentry里携带了要查找的文件name。该函数里需要调用d_add()将找到的inode插入到dentry。
 * 并且inode的i_count字段需要递增。如果inode没有找到，则dentry插入一个NULL inode（这种dentry称为一个negative dentry）。
 * 只有在底层真实错误时才能返回error，此时open、create、mknode等涉及创建inode的操作都会失败。同样也只有目录类型的inode才会调用该函数指针。
 * 在lookup函数里，可以将dentry的d_op字段初始化为自己的dentry_operations，来定制对dentry和dcache的一些管理函数操作合集。
*/
	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);

	const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);

/* VFS调用，用于检测访问权限。有可能在rcu-walk mode下被调用，那么该函数必须不能阻塞或者存储数据到inode。如果在rcu-walk mode下遇到问题，则返回-ECHILD，它将在ref-walk mode重新被调用。*/
	int (*permission) (struct inode *, int);

	struct posix_acl * (*get_acl)(struct inode *, int);

/* readlink系统调用使用，用于读取软链接文件指向的实际路径 */
	int (*readlink) (struct dentry *, char __user *,int);

/* 在某个目录下，为与dentry目录项相关的常规文件创建一个新的磁盘索引节点 */
	int (*create) (struct inode *,struct dentry *, umode_t, bool);

/* 创建硬链接 */
	int (*link) (struct dentry *,struct inode *,struct dentry *);

/* unlink系统调用使用，用于删除一个inode关联的文件或目录 */
	int (*unlink) (struct inode *,struct dentry *);

/* symlink系统调用使用，用于创建一个软链接 */
	int (*symlink) (struct inode *,struct dentry *,const char *);

/* mkdir系统调用使用，用于创建一个子目录 */
	int (*mkdir) (struct inode *,struct dentry *,umode_t);

/* rmdir系统调用使用，用于删除一个子目录。 */
	int (*rmdir) (struct inode *,struct dentry *);

/* 在dir目录下，为与目录项对象相关的特殊文件创建一个新的磁盘索引节点。其中参数mode 和 rdev分别表示文件的类型和该设备的主码。 */
	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);

/* rename系统调用使用，用于改名 */
	int (*rename) (struct inode *, struct dentry *,
			struct inode *, struct dentry *, unsigned int);

/* VFS调用，用于设置文件的attr属性。它将被chmod等相关系统调用使用 */
	int (*setattr) (struct dentry *, struct iattr *);

/* VFS调用，用于获取文件的attr属性。它将被stat等相关系统调用使用 */
	int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);

/* VFS调用，用于列出给定文件的所有扩展属性。它将被listxattr系统调用使用 */
	ssize_t (*listxattr) (struct dentry *, char *, size_t);

/*  */
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
		      u64 len);

/* VFS调用，用于更新inode的时间（如atime）或者i_version字段。如果该函数没有指定，则VFS将自己更新inode并调用mark_inode_dirty_sync */
	int (*update_time)(struct inode *, struct timespec *, int);

/* 可选函数，用于性能优化，它将lookup、可能的create操作以及open操作在一个接口里完成。只有negative dentry才会调用该函数。在dentry cache里的positive dentry直接通过f_op->open()函数来打开文件即可*/
	int (*atomic_open)(struct inode *, struct dentry *,
			   struct file *, unsigned open_flag,
			   umode_t create_mode, int *opened);

	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct inode *, struct posix_acl *, int);
} ____cacheline_aligned;
```

### i_private

```c
struct inode {
/* 一个 vfs 和 后端具体文件系统的纽带, 用来传递一些具体文件系统使用的数据结构*/
	void			*i_private; /* fs or device private pointer */
}
```

## file

```c
/*
 * include\linux\fs.h
*/

struct file {
	union {
		struct llist_node	fu_llist;     // 文件对象链表指针(linux/include/linux/list.h)
		struct rcu_head 	fu_rcuhead;   // RCU
	} f_u;
	struct path		f_path;             // 文件路径，包含dentry对象和mnt
	struct inode		*f_inode;	        // cached value 
	const struct file_operations	*f_op;  // 文件相关操作函数

	/*
	 * Protects f_ep_links, f_flags.
	 * Must not be taken from IRQ context.
	 */
	spinlock_t		f_lock;
	enum rw_hint		f_write_hint;
	atomic_long_t		f_count;              // 文件的引用计数
	unsigned int 		f_flags;              // 文件打开方式(open时指定)
	fmode_t			f_mode;                   // 读写模式：open的mod_t mode参数
	struct mutex		f_pos_lock;
	loff_t			f_pos;                    // 当前进程文件偏移量
	struct fown_struct	f_owner;          
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;

	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	/* needed for tty driver, and maybe others */
	void			*private_data;               // tty驱动程序所需

#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct list_head	f_ep_links;
	struct list_head	f_tfile_llink;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
	errseq_t		f_wb_err;
} __randomize_layout
```

### address_space

1. address_space 是Linux内核中的一个关键抽象，它是页缓存和外部设备中文件系统的桥梁，上层应用读取数据会进入到该结构内的page cache，上层应用对文件的写入内容也会缓存于该结构内的page cache；
2. 该结构是处理文件读写的中转站，关联了内存系统和文件系统，用于管理文件映射到内存的页面，一个 address_space与一个偏移量能够确定一个page cache 或swap cache中的一个页面；

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled%203.png)

```c
/*
 * include\linux\fs.h

*/
struct address_space {
	struct inode		*host;	         // address_space对应的文件的inode
	struct radix_tree_root	i_pages; // 指向了这个地址空间对应的页缓存的基数树,这样就可以通过 inode --> address_space -->i_pages 找到文件对应缓存页
	atomic_t		i_mmap_writable;     // count VM_SHARED mappings 共享映射数 VM_SHARED计数*/
	struct rb_root_cached	i_mmap;		 // tree of private and shared mappings 优先搜索树树根*/
	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
	/* Protected by the i_pages lock */
	unsigned long		nrpages;	       // 文件页总数
	/* number of shadow or DAX exceptional entries */
	unsigned long		nrexceptional;
	pgoff_t			writeback_index;/* writeback starts here */
/* 
 * 一个基类指针，定义了抽象的文件系统交互接口，由具体文件系统负责实现。
 * 例如如果文件是存储在ext4文件系统之上，那么该结构便被初始化为ext4_aops(fs/ext4/inode.c)
*/
	const struct address_space_operations *a_ops;	
	unsigned long		flags;		/* error bits */
	spinlock_t		private_lock;	/* for use by the address_space */
	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
	struct list_head	private_list;	/* for use by the address_space */
	void			*private_data;	/* ditto */
	errseq_t		wb_err;
} __attribute__((aligned(sizeof(long)))) __randomize_layout;
```

### ext4_aops

```c
/*
 * fs\ext4\inode.c
*/
static const struct address_space_operations ext4_aops = {
	.readpage		= ext4_readpage,
	.readpages		= ext4_readpages,
	.writepage		= ext4_writepage,
	.writepages		= ext4_writepages,
	.write_begin		= ext4_write_begin,
	.write_end		= ext4_write_end,
	.set_page_dirty		= ext4_set_page_dirty,
	.bmap			= ext4_bmap,
	.invalidatepage		= ext4_invalidatepage,
	.releasepage		= ext4_releasepage,
	.direct_IO		= ext4_direct_IO,
	.migratepage		= buffer_migrate_page,
	.is_partially_uptodate  = block_is_partially_uptodate,
	.error_remove_page	= generic_error_remove_page,
};
```

### ext4_bmap

```c
/*
 * fs\ext4\inodsupere.c
 * bmap() is special.  It gets used by applications such as lilo and by
 * the swapper to find the on-disk block of a specific piece of data.
 *
 * Naturally, this is dangerous if the block concerned is still in the
 * journal.  If somebody makes a swapfile on an ext4 data-journaling
 * filesystem and enables swap, then they may get a nasty shock when the
 * data getting swapped to that swapfile suddenly gets overwritten by
 * the original zero's written out previously to the journal and
 * awaiting writeback in the kernel's buffer cache.
 *
 * So, if we see any bmap calls here on a modified, data-journaled file,
 * take extra steps to flush any blocks which might be in the cache.
*/
static sector_t ext4_bmap(struct address_space *mapping, sector_t block)
{
  /* 获取文件对应inode */
	struct inode *inode = mapping->host;
  /* 日志 具体作用不知道*/
	journal_t *journal;
  /* 错误码 */
	int err;

	/*
	 * We can get here for an inline file via the FIBMAP ioctl
	 */
	if (ext4_has_inline_data(inode))
		return 0;

	if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) &&
			test_opt(inode->i_sb, DELALLOC)) {
		/*
		 * With delalloc we want to sync the file
		 * so that we can make sure we allocate
		 * blocks for file
		 */
		filemap_write_and_wait(mapping);
	}

	if (EXT4_JOURNAL(inode) &&
	    ext4_test_inode_state(inode, EXT4_STATE_JDATA)) {
		/*
		 * This is a REALLY heavyweight approach, but the use of
		 * bmap on dirty files is expected to be extremely rare:
		 * only if we run lilo or swapon on a freshly made file
		 * do we expect this to happen.
		 *
		 * (bmap requires CAP_SYS_RAWIO so this does not
		 * represent an unprivileged user DOS attack --- we'd be
		 * in trouble if mortal users could trigger this path at
		 * will.)
		 *
		 * NB. EXT4_STATE_JDATA is not set on files other than
		 * regular files.  If somebody wants to bmap a directory
		 * or symlink and gets confused because the buffer
		 * hasn't yet been flushed to disk, they deserve
		 * everything they get.
		 */

		ext4_clear_inode_state(inode, EXT4_STATE_JDATA);
		journal = EXT4_JOURNAL(inode);
		jbd2_journal_lock_updates(journal);
		err = jbd2_journal_flush(journal);
		jbd2_journal_unlock_updates(journal);

		if (err)
			return 0;
	}

	return generic_block_bmap(mapping, block, ext4_get_block);
}
```

```c
sector_t generic_block_bmap(struct address_space *mapping, sector_t block,
			    get_block_t *get_block)
{
	struct inode *inode = mapping->host;
	struct buffer_head tmp = {
		.b_size = i_blocksize(inode),
	};

	get_block(inode, block, &tmp, 0);
	return tmp.b_blocknr;
```

```c
/*
 * fs\ext4\inode.c
*/
int ext4_get_block(struct inode *inode, sector_t iblock,
		   struct buffer_head *bh, int create)
{
	return _ext4_get_block(inode, iblock, bh,
			       create ? EXT4_GET_BLOCKS_CREATE : 0);
}
```

```c
/*
 * fs\ext4\inode.c
*/
static int _ext4_get_block(struct inode *inode, sector_t iblock,
			   struct buffer_head *bh, int flags)
{
	struct ext4_map_blocks map;
	int ret = 0;

/* 是否有inline data */
	if (ext4_has_inline_data(inode))
		return -ERANGE;

	map.m_lblk = iblock;
	map.m_len = bh->b_size >> inode->i_blkbits;

	ret = ext4_map_blocks(ext4_journal_current_handle(), inode, &map,
			      flags);
	if (ret > 0) {
		map_bh(bh, inode->i_sb, map.m_pblk);
		ext4_update_bh_state(bh, map.m_flags);
		bh->b_size = inode->i_sb->s_blocksize * map.m_len;
		ret = 0;
	} else if (ret == 0) {
		/* hole case, need to fill in bh->b_size */
		bh->b_size = inode->i_sb->s_blocksize * map.m_len;
	}
	return ret;
}
```

### struct ext4_map_blocks

```c
struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;       //起始物理块号（填充返回参数）
	ext4_lblk_t m_lblk;        //起始逻辑块号 （传入参数）
	unsigned int m_len;        //逻辑块数量，同时这个参数也作为返回值保存实际映射物理块的长度
	unsigned int m_flags;      //块状态（填充返回参数）
}
```

## dentry

```c
/*
 * include\linux\dcache.h
*/
struct dentry {
	/* RCU lookup touched fields */
	unsigned int d_flags;		    // protected by d_lock , 目录项标志
	seqcount_t d_seq;		        // per dentry seqlock
	struct hlist_bl_node d_hash;// lookup hash list 散列表项指针
	struct dentry *d_parent;	  // parent directory
	struct qstr d_name;         // 文件名
	struct inode *d_inode;		  // Where the name belongs to - NULL is * negative 
	unsigned char d_iname[DNAME_INLINE_LEN];	// 短文件名

	/* Ref lookup also touches following */
	struct lockref d_lockref;	/* per-dentry lock and refcount */
	const struct dentry_operations *d_op;// dentry相关操作函数
	struct super_block *d_sb;	           // 文件的super_block
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */

	union {
		struct list_head d_lru;		/* LRU list */
		wait_queue_head_t *d_wait;	/* in-lookup ones only */
	};
	struct list_head d_child;  	  // child of parent list
	struct list_head d_subdirs;	  // 对目录而言，表示子目录dentry的链表
	/*
	 * d_alias and d_rcu can share memory
	 */
	union {
		struct hlist_node d_alias;	          // 相关inode的链表
		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
	 	struct rcu_head d_rcu;
	} d_u;
} __randomize_layout;
```

# EXT4

## EXT4磁盘分布—group

### 扇区、block、group

ext4文件系统将磁盘扇区组合为一个个大小相同的逻辑块block（默认是4KB），然后将多个block组合成group（最大为128KB，默认为128KB），group大小计算公式如下：

$Group_size = (blk_size8)blk_size=409684096= 32768*4096=128M$

### group简单分析（group0）

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled%204.png)

- Group padding ：group0 开始的1024bytes用作它用（比如启动引导），也只有group0的前1024bytes是保留的。
- ext4 super block ：超级块，记录文件系统属性，大小约为0x2D0（720）bytes。
    - 如果block块大小为2K或4K，那么super block将存放在第一个block（索引为0）中；
    - 如果block块为1K，则super block将存放在第二个block（索引为1）中；
    - 如果block块为512bytes(很少设置为这个值了)，则super block将存放在第三、四个block（索引为2,3）中；
- Group Descriptors blocks(简称GDBs)：每一个描述符的大小64byte，GDBs所占用block多少是与卷的大小有关的；
- Reserved GDT Blocks(简称RGDTBs)：为卷扩容预留的空间；
- Data block bitmap：用于描述本group（即对应所在的group）内各个block块的使用状态，一个bit位对应标识一个block块，如果该bit为0，则表示对应block块为空闲状态，否则表示为使用状态或其它（比如物理上不存在，发生在最后一个group最靠后的位置）。
- Inode bitmap：用于描述本group（即对应所在的group）内inodetable中各个inode项的使用状态，一个bit位对应标识一个inode项，如果该bit为0，则表示对应inode table的inode项为空闲状态，否则表示为使用状态。即一个group最多有 4096 * 8 = 32768个inode；
- Inode table:用于存放inode数据，一个inode数据大小为256bytes，inode table默认为512个block，所以一个group中的文件多少默认为512*4096/256=8192个。
- Data block：（除去之前那么几类数据，剩余的block全部为data blocks）用于存放普通数据。
- inode table 和inode bitmap对inode的数量限制取最小值；

## inode、ext4_inode、ext4_inode_info

- inode是VFS层文件内存数据结构，其中记录所有文件系统inode部分公共成员，同时也有部分成员是为VFS层管理之用。
- ext4_inode_info是ext4文件系统的内存inode，与inode是父类和子类的关系，可以通过强制类型转换进行相互转换
- ext4_inode是存储在磁盘上的数据结构

![Untitled](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5B%E5%BE%85%E5%AE%8C%E5%96%84%5D%205477c0bada114e1ab7537a52ff91bdf0/Untitled%205.png)

## ext4_inode

```c
/*
 * Structure of an inode on the disk
 */
struct ext4_inode {
	__le16	i_mode;		/* File mode */
	__le16	i_uid;		/* Low 16 bits of Owner Uid */
	__le32	i_size_lo;	/* Size in bytes 文件占用块数*/
	__le32	i_atime;	/* Access time */
	__le32	i_ctime;	/* Inode Change time */
	__le32	i_mtime;	/* Modification time */
  __le32	i_dtime;	/* Deletion Time */
	__le16	i_gid;		/* Low 16 bits of Group Id */
	__le16	i_links_count;	/* Links count */
	__le32	i_blocks_lo;	/* Blocks count */
	__le32	i_flags;	/* File flags */
	union {
		struct {
			__le32  l_i_version;
		} linux1;
		struct {
			__u32  h_i_translator;
		} hurd1;
		struct {
			__u32  m_i_reserved1;
		} masix1;
	} osd1;				/* OS dependent 1 */
	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */
	__le32	i_generation;	/* File version (for NFS) */
	__le32	i_file_acl_lo;	/* File ACL */
	__le32	i_size_high;
	__le32	i_obso_faddr;	/* Obsoleted fragment address */
	union {
		struct {
			__le16	l_i_blocks_high; /* were l_i_reserved1 */
			__le16	l_i_file_acl_high;
			__le16	l_i_uid_high;	/* these 2 fields */
			__le16	l_i_gid_high;	/* were reserved2[0] */
			__le16	l_i_checksum_lo;/* crc32c(uuid+inum+inode) LE */
			__le16	l_i_reserved;
		} linux2;
		struct {
			__le16	h_i_reserved1;	/* Obsoleted fragment number/size which are removed in ext4 */
			__u16	h_i_mode_high;
			__u16	h_i_uid_high;
			__u16	h_i_gid_high;
			__u32	h_i_author;
		} hurd2;
		struct {
			__le16	h_i_reserved1;	/* Obsoleted fragment number/size which are removed in ext4 */
			__le16	m_i_file_acl_high;
			__u32	m_i_reserved2[2];
		} masix2;
	} osd2;				/* OS dependent 2 */
	__le16	i_extra_isize;
	__le16	i_checksum_hi;	/* crc32c(uuid+inum+inode) BE */
	__le32  i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */
	__le32  i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */
	__le32  i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */
	__le32  i_crtime;       /* File Creation time */
	__le32  i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */
	__le32  i_version_hi;	/* high 32 bits for 64-bit version */
	__le32	i_projid;	/* Project ID */
};
```

### i_block

- 该成员存储了文件内容的每一逻辑块

```c
struct ext4_inode{
	...
	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */
	...
}
/*
 * ext4_block_to_path() // fs\ext4\indirect.c

 * ext4_read_inline_data() // fs\ext4\inline.c
 * ext4_write_inline_data()
 * ext4_create_inline_data()
 * ext4_destroy_inline_data_nolock()
 * ext4_try_add_inline_entry()
 * ext4_get_first_inline_block()
 * ext4_try_create_inline_dir()
 * ext4_find_inline_entry()
 * ext4_delete_inline_entry()
 * ext4_get_inline_entry()
 * empty_inline_dir()
 * ext4_inline_data_iomap()
 * ext4_inline_data_fiemap()
 * ext4_inline_data_truncate()
 
 * ext4_iget() // fs/ext4/inode.c
 * ext4_do_update_inode()

 * ufs_block_to_path() // fs/ufs/inode.c

*/
```

## ext4_inode_info

```c
/*
 * fourth extended file system inode data in memory
 */
struct ext4_inode_info {
	__le32	i_data[15];	/* unconverted */
	__u32	i_dtime;
	ext4_fsblk_t	i_file_acl;

	/*
	 * i_block_group is the number of the block group which contains
	 * this file's inode.  Constant across the lifetime of the inode,
	 * it is used for making block allocation decisions - we try to
	 * place a file's data blocks near its inode block, and new inodes
	 * near to their parent directory's inode.
	 */
	ext4_group_t	i_block_group;
	ext4_lblk_t	i_dir_start_lookup;
#if (BITS_PER_LONG < 64)
	unsigned long	i_state_flags;		/* Dynamic state flags */
#endif
	unsigned long	i_flags;

	/*
	 * Extended attributes can be read independently of the main file
	 * data. Taking i_mutex even when reading would cause contention
	 * between readers of EAs and writers of regular file data, so
	 * instead we synchronize on xattr_sem when reading or changing
	 * EAs.
	 */
	struct rw_semaphore xattr_sem;

	struct list_head i_orphan;	/* unlinked but open inodes */

	/*
	 * i_disksize keeps track of what the inode size is ON DISK, not
	 * in memory.  During truncate, i_size is set to the new size by
	 * the VFS prior to calling ext4_truncate(), but the filesystem won't
	 * set i_disksize to 0 until the truncate is actually under way.
	 *
	 * The intent is that i_disksize always represents the blocks which
	 * are used by this file.  This allows recovery to restart truncate
	 * on orphans if we crash during truncate.  We actually write i_disksize
	 * into the on-disk inode when writing inodes out, instead of i_size.
	 *
	 * The only time when i_disksize and i_size may be different is when
	 * a truncate is in progress.  The only things which change i_disksize
	 * are ext4_get_block (growth) and ext4_truncate (shrinkth).
	 */
	loff_t	i_disksize;

	/*
	 * i_data_sem is for serialising ext4_truncate() against
	 * ext4_getblock().  In the 2.4 ext2 design, great chunks of inode's
	 * data tree are chopped off during truncate. We can't do that in
	 * ext4 because whenever we perform intermediate commits during
	 * truncate, the inode and all the metadata blocks *must* be in a
	 * consistent state which allows truncation of the orphans to restart
	 * during recovery.  Hence we must fix the get_block-vs-truncate race
	 * by other means, so we have i_data_sem.
	 */
	struct rw_semaphore i_data_sem;
	/*
	 * i_mmap_sem is for serializing page faults with truncate / punch hole
	 * operations. We have to make sure that new page cannot be faulted in
	 * a section of the inode that is being punched. We cannot easily use
	 * i_data_sem for this since we need protection for the whole punch
	 * operation and i_data_sem ranks below transaction start so we have
	 * to occasionally drop it.
	 */
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;

	spinlock_t i_raw_lock;	/* protects updates to the raw inode */

	/*
	 * File creation time. Its function is same as that of
	 * struct timespec i_{a,c,m}time in the generic inode.
	 */
	struct timespec i_crtime;

	/* mballoc */
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;

	/* extents status tree */
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;	/* protected by i_es_lock */
	unsigned int i_es_shk_nr;	/* protected by i_es_lock */
	ext4_lblk_t i_es_shrink_lblk;	/* Offset where we start searching for
					   extents to shrink. Protected by
					   i_es_lock  */

	/* ialloc */
	ext4_group_t	i_last_alloc_group;

	/* allocation reservation info for delalloc */
	/* In case of bigalloc, this refer to clusters rather than blocks */
	unsigned int i_reserved_data_blocks;
	ext4_lblk_t i_da_metadata_calc_last_lblock;
	int i_da_metadata_calc_len;

	/* on-disk additional length */
	__u16 i_extra_isize;

	/* Indicate the inline data space. */
	u16 i_inline_off;
	u16 i_inline_size;

#ifdef CONFIG_QUOTA
	/* quota space reservation, managed internally by quota code */
	qsize_t i_reserved_quota;
#endif

	/* Lock protecting lists below */
	spinlock_t i_completed_io_lock;
	/*
	 * Completed IOs that need unwritten extents handling and have
	 * transaction reserved
	 */
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten; /* Nr. of inflight conversions pending */

	spinlock_t i_block_reservation_lock;

	/*
	 * Transactions that contain inode's metadata needed to complete
	 * fsync and fdatasync, respectively.
	 */
	tid_t i_sync_tid;
	tid_t i_datasync_tid;

#ifdef CONFIG_QUOTA
	struct dquot *i_dquot[MAXQUOTAS];
#endif

	/* Precomputed uuid+inum+igen checksum for seeding inode checksums */
	__u32 i_csum_seed;

	kprojid_t i_projid;
};
```

## vfs inode  和 EXT4 inode

### 强制类型转换

1. vfs inode 出生就和 ext4_inode_info 结构体分配在一起的（ext4_inode_info结构体里面定义了vfs的struct inode），直接通过 vfs inode 结构体的地址强转类型就能得到 ext4_inode_info 结构体；
2. 分配 inode 的时候，其实分配的是 ext4_inode_info 结构体，包含了 vfs inode，然后对外给出去 vfs_inode 字段的地址即可。VFS 层拿 inode 的地址使用，底下文件系统强转类型后，取外层的 inode 地址使用；
3. 总结：inode 的内存由后端文件系统分配，vfs inode 结构体内嵌在不同的文件系统的 inode 之中。不同的层次用不同的地址，ext4 文件系统用 ext4_inode_info 的结构体的地址，vfs 层用 ext4_inode_info.vfs_inode 字段的地址。

```c
// fs/etx4/super.c
/*
 * 分配 ext4_inode_info ，返回vfs inode，VFS拿到的就是这个inode地址
*/
static struct inode *ext4_alloc_inode(struct super_block *sb)
{
	struct ext4_inode_info *ei;
/* 内存分配，分配 ext4_inode_info 的地址 */
	ei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);

	if (!ei)
		return NULL;

/* ext4_inode_info 结构体初始化 */
	inode_set_iversion(&ei->vfs_inode, 1);
	spin_lock_init(&ei->i_raw_lock);
	INIT_LIST_HEAD(&ei->i_prealloc_list);
	spin_lock_init(&ei->i_prealloc_lock);
	ext4_es_init_tree(&ei->i_es_tree);
	rwlock_init(&ei->i_es_lock);
	INIT_LIST_HEAD(&ei->i_es_list);
	ei->i_es_all_nr = 0;
	ei->i_es_shk_nr = 0;
	ei->i_es_shrink_lblk = 0;
	ei->i_reserved_data_blocks = 0;
	ei->i_da_metadata_calc_len = 0;
	ei->i_da_metadata_calc_last_lblock = 0;
	spin_lock_init(&(ei->i_block_reservation_lock));
#ifdef CONFIG_QUOTA
	ei->i_reserved_quota = 0;
	memset(&ei->i_dquot, 0, sizeof(ei->i_dquot));
#endif
	ei->jinode = NULL;
	INIT_LIST_HEAD(&ei->i_rsv_conversion_list);
	spin_lock_init(&ei->i_completed_io_lock);
	ei->i_sync_tid = 0;
	ei->i_datasync_tid = 0;
	atomic_set(&ei->i_unwritten, 0);
	INIT_WORK(&ei->i_rsv_conversion_work, ext4_end_io_rsv_work);

/* 返回 vfs_inode 字段的地址 */
	return &ei->vfs_inode;
}
```

### 强制类型转换函数 EXT4_I

```c
// fs\ext4\ext4.h
/*
 * ext4 封装的一个强制类型转换函数，只要知道struct inode的地址，就可以通过该函数
 * 得到ext4_inode_info 结构体地址 */
static inline struct ext4_inode_info *EXT4_I(struct inode *inode)
{
	return container_of(inode, struct ext4_inode_info, vfs_inode);
}

// include\linux\kernel.h
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
			 !__same_type(*(ptr), void),			\
			 "pointer type mismatch in container_of()");	\
	((type *)(__mptr - offsetof(type, member))); })
```

# 参考

source     article-tile       author

[知乎 《文件系统的原理》 兰新宇](https://zhuanlan.zhihu.com/p/106459445)

[腾讯云社区 《存储基础 — 文件描述符 fd 究竟是什么？》 IOT物联网小镇](https://cloud.tencent.com/developer/article/1823039)

[知乎 《[简译] VFS的相关数据结构和操作》兰新宇](https://zhuanlan.zhihu.com/p/262559780)

[segmentfault 《一口气搞懂「文件系统」，就靠这 25 张图了》 小林coding](https://segmentfault.com/a/1190000023615225)

[CSDN 《[ext4]磁盘布局 - group分析》 YoungerChina](https://blog.csdn.net/younger_china/article/details/21184967)

[《Ext4 Disk Layout》](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#)

[Blog 《Linux操作系统学习笔记（十一）文件系统》 Ty-Chen's](https://ty-chen.github.io/linux-kernel-fs/)

[Blog 《Linux虚拟文件系统(VFS)》 Arking](https://arkingc.github.io/2017/08/18/2017-08-18-linux-code-vfs/)

[知乎 《Linux IO核心数据结构之一》 丁凯](https://zhuanlan.zhihu.com/p/46031338)

[腾讯云社区 《Linux删除文件过程解析》 腾讯数据库技术](https://cloud.tencent.com/developer/article/1143433)

[CSDN 《linux内核中的address_space 结构解析》土豆西瓜大芝麻](https://blog.csdn.net/jinking01/article/details/106490467)

[CSDN 《struct files_struct和struct fdtable》  metersun](https://blog.csdn.net/metersun/article/details/80513702)

[博客园 《[ext4]空间管理 - 查找块》 YoungerChina](https://www.cnblogs.com/youngerchina/p/5624476.html)